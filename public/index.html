<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>BackboneBook</title>
    <link rel="stylesheet" href="css/style.css"/>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>
</head>

<nav class="grey">
    <div class="topnav">
        <ul id="nav-mobile" class="nav nav-pills nav-justified">
            <li><a class="btn btn-info btn-lg"  href="cabinet.html" id="reload">Reload</a></li>
            <li><a class="btn btn-info btn-lg"  href="cabinet.html" id="home">Домашня</a></li>
            <li><a class="btn btn-info btn-lg"  data-toggle="modal" data-target="#modal1" id="reg_btn">Реєстрація</a></li>
            <li><a class="btn btn-info btn-lg"  data-toggle="modal" data-target="#modal2" id="log">Увійти</a></li>
            </ul>
    </div> 
</nav>
 <div class="modal fade" id="modal1" role="dialog">
        <div class="modal-dialog modal-sm">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="form-group col-md-4 pull-left">
                                <h4 class="modal-title">Введіть дані</h4>

                                <label for="login">Логін</label><input id="login" type="text" ><span id="l_valid"></span>

                                <label for="password">Пароль</label><input id="password" type="password" ><span id="p_valid"></span>

                                <label for="email">Email</label><input id="email" name="mail" type="text"><span id="e_valid"></span>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <input type="submit" value="Реєстрація" id="submit" disabled="true" class="btn btn-info btn-lg pull-left"  onclick="window.backboneBook.registration()">
                        <a href="#" class="btn btn-info btn-lg" data-dismiss="modal">Закрити вікно</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="modal2" role="dialog">
        <div class="modal-dialog modal-sm">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="form-group col-md-4 pull-left">
                                <h4 class="modal-title">Введіть дані</h4>
                                <input id="login_user" type="text" class="validate">
                                <label for="login_user">Логін</label>
                                <input id="pw_user" type="text" class="validate">
                                <label for="pw_user">Пароль</label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <a href="#" class="btn btn-info btn-lg puii-left" onclick="window.backboneBook.user()">Увійти</a>
                        <a href="#" class="btn btn-info btn-lg" data-dismiss="modal">Закрити вікно</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
<div class="container">
    <div class="content">
        <div>
            <h3>Паттерн Builder</h3>
            <p><b><i>Название и классификация паттерна</i></b></p>
            <p>Строитель - паттерн, порождающий объекты.</p>
            <p><b><i>Назначение</i></b></p>
            <p>Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.</p>
            <p><b><i>Мотивация</i></b></p>
            <p>Программа, в которую заложена возможность распознавания и чтения документа в формате RTF (Rich Text Format), должна также «уметь» преобразовывать его во многие другие
                форматы, например в простой ASCII-текст или в представление, которое можно отобразить в виджете для ввода текста. Однако число вероятных преобразований заранее неизвестно.
                Поэтому должна быть обеспечена возможность без труда добавлять новый конвертор.</p>
            <p>Таким образом, нужно сконфигурировать класс RTFReader с помощью объекта Text Converter, который мог бы преобразовывать RTF в другой текстовый формат.
                При разборе документа в формате RTF класс RTFReader вызывает TextConverter для выполнения преобразования. Всякий раз, как RTFReader распознает лексему RTF
                (простой текст или управляющее слово), для ее преобразования объекту TextConverter посылается запрос. Объекты TextConverter отвечают как за преобразование
                данных, так и за представление лексемы в конкретном формате.</p>
            <p>Подклассы TextConverter специализируются на различных преобразованиях и форматах. Например, ASCIIConverter игнорирует запросы на преобразование чего бы то
                ни было, кроме простого текста. С другой стороны, TeXConverter будет реализовывать все запросы для получения представления в формате редактора TJX, собирая
                по ходу необходимую информацию о стилях. A TextWidget Converter станет строить сложный объект пользовательского интерфейса, который позволит пользователю
                просматривать и редактировать текст.</p>
            <img src="img/book/103.jpg" alt="Мотивация">
            <p>Класс каждого конвертора принимает механизм создания и сборки сложного объекта и скрывает его за абстрактным интерфейсом. Конвертор отделен от загрузчика,
                который отвечает за синтаксический разбор RTF-документа.</p>
            <p>В паттерне строитель абстрагированы все эти отношения. В нем любой класс конвертора называется <i>строителем</i>, а загрузчик - <i>распорядителем</i>. В применении к рассмотренному
                примеру строитель отделяет алгоритм интерпретации формата текста (то есть анализатор RTF-документов) от того, как создается и представляется документ в
                преобразованном формате. Это позволяет повторно использовать алгоритм разбора, реализованный в RTFReader, для создания разных текстовых представлений RTF-документов;
                достаточно передать в RTFReader различные подклассы класса Text Converter.</p>
            <p><b><i>Применимость</i></b></p>
            <p>Используйте паттерн строитель, когда:</p>
            <ul>
                <li> алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;</li>
                <li> процесс конструирования должен обеспечивать различные представления конструируемого объекта.</li>
            </ul>
            <p><b><i>Структура</i></b></p>

            <img src="img/book/104.jpg" alt="Структура">

            <p><b><i>Участники</i></b></p>
            <ul>
                <li><b>Builder</b> (TextConverter) - строитель:
                    <ul>
                        <li>-	задает абстрактный интерфейс для создания частей объекта Product;</li>
                    </ul></li>
                <li>ConcreteBuilder(ASCIIConverter, TeXConverter, TextWidgetConverter)- конкретный строитель:
                    <ul>
                        <li>-	конструирует и собирает вместе части продукта посредством реализации интерфейса Builder;</li>
                        <li>-	определяет создаваемое представление и следит за ним;</li>
                        <li>-	предоставляет интерфейс для доступа к продукту (например, GetASCI IText, GetT extWidget);</li>
                    </ul></li>
                <li> <b>Director</b> (RTFReader) - распорядитель:
                    <ul>
                        <li>-	конструирует объект, пользуясь интерфейсом Builder; </li>
                    </ul></li>
                <li><b>Product</b> (ASCIIText, TeXText, TextWidget) - продукт:
                    <ul>
                        <li>-	представляет сложный конструируемый объект. ConcreteBuilder строит внутреннее представление продукта и определяет процесс его сборки;</li>
                        <li>-	включает классы, которые определяют составные части, в том числе ин-терфейсы для сборки конечного результата из частей.</li>
                    </ul></li>
            </ul>
            <p><b><i>Отношения</i></b></p>
            <ul>
                <li> клиент создает объект-распорядитель Director и конфигурирует его нужным объектом-строителем Builder;</li>
                <li> распорядитель уведомляет строителя о том, что нужно построить очередную часть продукта;</li>
                <li> строитель обрабатывает запросы распорядителя и добавляет новые части к продукту;</li>
                <li> клиент забирает продукт у строителя.</li>
            </ul>
            <p>Следующая диаграмма взаимодействий иллюстрирует взаимоотношения строителя и распорядителя с клиентом.</p>

            <img src="img/book/105.jpg" alt="Схема отношения строителя и распорядителя с клиентом">


            <p><b><i>Результаты</i></b></p>
            <p>Плюсы и минусы паттерна строитель и его применения:</p>
            <ul>
                <li> <i>позволяет изменять внутреннее представление продукта</i>. Объект Builder предоставляет распорядителю абстрактный интерфейс для конструирования продукта, за которым
                    он может скрыть представление и внутреннюю структуру продукта, а также процесс его сборки. Поскольку продукт конструируется через абстрактный интерфейс,
                    то для изменения внутреннего представления достаточно всего лишь определить новый вид строителя;</li>
                <li> <i>изолирует код, реализующий конструирование и представление</i>. Паттерн строитель улучшает модульность, инкапсулируя способ конструирования и представления
                    сложного объекта. Клиентам ничего не надо знать о классах, определяющих внутреннюю структуру продукта, они отсутствуют в интерфейсе строителя.
                    <p>Каждый конкретный строитель ConcreteBuilder содержит весь код, необходимый для создания и сборки конкретного вида продукта. Код пишется только один раз,
                        после чего разные распорядители могут использовать его повторно для построения вариантов продукта из одних и тех же частей. В примере с RTF-документом мы могли
                        бы определить загрузчик для формата, отличного от RTF, скажем, SGMLReader, и воспользоваться теми же самыми классами TextConverters
                        для генерирования представлений SGML-документов в виде ASCII-текста, ТеХ-текста или текстового виджета;</p></li>
                <li> <i>дает более тонкий контроль над процессом конструирования</i>. В отличие от порождающих паттернов, которые сразу конструируют весь объект целиком,
                    строитель делает это шаг за шагом под управлением распорядителя. И лишь когда продукт завершен, распорядитель забирает его у строителя.
                    Поэтому интерфейс строителя в большей степени отражает процесс конструирования продукта, нежели другие порождающие паттерны.
                    Это позволяет обеспечить более тонкий контроль над процессом конструирования, а значит, и над внутренней структурой готового продукта.</li>
            </ul>
            <p><b><i>Реализация</i></b></p>
            <p>Обычно существует абстрактный класс Builder, в котором определены операции для каждого компонента, который распорядитель может «попросить» создать.
                По умолчанию эти операции ничего не делают. Но в классе конкретного строите¬ля ConcreteBuilder они замещены для тех компонентов, в создании которых он принимает участие.</p>
            <p>Вот еще некоторые достойные внимания вопросы реализации:</p>
            <ul>
                <li> <i>интерфейс сборки и конструирования</i>. Строители конструируют свои продукты шаг за шагом. Поэтому интерфейс класса Builder должен быть достаточно общим,
                    чтобы обеспечить конструирование при любом виде конкретного строителя.
                    <p>Ключевой вопрос проектирования связан с выбором модели процесса кон-струирования и сборки. Обычно бывает достаточно модели, в которой результаты выполнения
                        запросов на конструирование просто добавляются к продукту. В примере с RTF-документами строитель преобразует и добавляет очередную лексему к уже конвертированному тексту.</p>
                    <p>Но иногда может потребоваться доступ к частям сконструированного к данному моменту продукта. В примере с лабиринтом, который будет описан в разделе «Пример кода»,
                        интерфейс класса MazeBui Ider позволяет добавлять дверь между уже существующими комнатами. Другим примером являются древовидные структуры, скажем, деревья
                        синтаксического разбора, которые строятся снизу вверх. В этом случае строитель должен был бы вернуть узлы-потомки распорядителю, который затем передал
                        бы их назад строителю, чтобы тот мог построить родительские узлы.</p></li>
                <li> <i>почему нет абстрактного класса для продуктов</i>. В типичном случае продукты, изготавливаемые различными строителями, имеют настолько разные представления,
                    что изобретение для них общего родительского класса ничего не дает. В примере с RTF-документами трудно представить себе общий интерфейс у объектов ASCIIText
                    и TextWidget, да он и не нужен. Поскольку клиент обычно конфигурирует распорядителя подходящим конкретным строителем, то, надо полагать, ему известно,
                    какой именно подкласс класса Builder используется и как нужно обращаться с произведенными продуктами;</li>
                <li> <i>пустые методы класса Builder no умолчанию</i>. В C++ методы строителя намеренно не объявлены чисто виртуальными функциями-членами. Вместо этого они определены
                    как пустые функции, что позволяет подклассу замещать только те операции, в которых он заинтересован.</li>
            </ul>
        </div>
</div>

<style id="app"></style>

<footer class="page-footer grey">
    <div class="footer-copyright">
        <div class="container">
            © 2016 Copyright Text
            <a class="grey-text text-lighten-4 right" href="#">Home</a>
        </div>
    </div>
</footer>
<script type="text/template" id="styleTemplate">
    body {
    font-size: <%- fontSize %>;
    color : <%- color %>;
    background: <%- background %>;
    text-align: <%- textAlign %>;
    }
</script>
<script type="text/javascript" src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone-min.js"></script>
<script type="text/javascript" src="scripts/index.js"></script>
<script type="text/javascript" src="scripts/validation.js"></script>

</body>
</html>